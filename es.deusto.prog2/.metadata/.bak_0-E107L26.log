!SESSION 2022-06-14 15:36:13.263 -----------------------------------------------
eclipse.buildId=4.19.0.I20210303-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\i.cubillo\OneDrive - Universidad de Deusto\Documentos\Eclipse\.metadata\.bak_0.log
Created Time: 2022-06-14 15:39:22.597

!ENTRY org.eclipse.jface 2 0 2022-06-14 15:39:22.597
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-14 15:39:22.597
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@38ebc866,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6adcf059,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-14 15:39:39.131
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\i.cubillo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.e4.ui.workbench 2 0 2022-06-14 15:39:39.189
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.debug.ui.launchView" id and the "Launch Configurations" label.It points to the non available "bundleclass://org.eclipse.debug.ui.launchview/org.eclipse.debug.ui.launchview.internal.view.LaunchViewImpl" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2022-06-14 15:39:39.195
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.m2e.core.views.MavenLifecycleMappingsView" id and the "Maven Lifecycle Mappings" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 15:41:07.732
!MESSAGE JavaBuilder handling CoreException while building: GestorTareas
!STACK 1
org.eclipse.core.runtime.CoreException: release 17 is not found in the system
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.initialize(ClasspathJrtWithReleaseOption.java:120)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:82)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:146)
	at org.eclipse.jdt.internal.core.builder.NameEnvironment.computeClasspathLocations(NameEnvironment.java:313)
	at org.eclipse.jdt.internal.core.builder.NameEnvironment.<init>(NameEnvironment.java:62)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.initializeBuilder(JavaBuilder.java:643)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:181)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:846)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:229)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:277)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:330)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:333)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:385)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:406)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.IllegalArgumentException: release 17 is not found in the system
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.initialize(ClasspathJrtWithReleaseOption.java:119)
	... 18 more
!SUBENTRY 1 org.eclipse.jdt.core 4 0 2022-06-14 15:41:07.733
!MESSAGE release 17 is not found in the system
!STACK 0
java.lang.IllegalArgumentException: release 17 is not found in the system
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.initialize(ClasspathJrtWithReleaseOption.java:119)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:82)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:146)
	at org.eclipse.jdt.internal.core.builder.NameEnvironment.computeClasspathLocations(NameEnvironment.java:313)
	at org.eclipse.jdt.internal.core.builder.NameEnvironment.<init>(NameEnvironment.java:62)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.initializeBuilder(JavaBuilder.java:643)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:181)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:846)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:229)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:277)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:330)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:333)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:385)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:406)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.ui 4 10001 2022-06-14 15:55:22.808
!MESSAGE Internal Error
!STACK 1
org.eclipse.jdt.internal.ui.JavaUIException: Problems reading information from XML 'QualifiedTypeNameHistory.xml'
	at org.eclipse.jdt.internal.corext.util.History.createException(History.java:77)
	at org.eclipse.jdt.internal.corext.util.History.load(History.java:258)
	at org.eclipse.jdt.internal.corext.util.History.load(History.java:174)
	at org.eclipse.jdt.internal.corext.util.QualifiedTypeNameHistory.<init>(QualifiedTypeNameHistory.java:36)
	at org.eclipse.jdt.internal.corext.util.QualifiedTypeNameHistory.getDefault(QualifiedTypeNameHistory.java:29)
	at org.eclipse.jdt.internal.corext.util.QualifiedTypeNameHistory.remember(QualifiedTypeNameHistory.java:61)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaTypeCompletionProposal.rememberSelection(LazyJavaTypeCompletionProposal.java:254)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaTypeCompletionProposal.apply(LazyJavaTypeCompletionProposal.java:217)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.apply(LazyGenericTypeProposal.java:274)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:508)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:446)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:999)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:948)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1373)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:800)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:766)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6101)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5795)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1094)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1519)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4882)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4760)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
Caused by: java.io.IOException: El proveedor de sincronización en la nube no pudo realizar la operación porque la red no está disponible
	at java.base/java.io.FileInputStream.readBytes(Native Method)
	at java.base/java.io.FileInputStream.read(FileInputStream.java:271)
	at java.base/sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:297)
	at java.base/sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:339)
	at java.base/sun.nio.cs.StreamDecoder.read(StreamDecoder.java:188)
	at java.base/java.io.InputStreamReader.read(InputStreamReader.java:181)
	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLEntityScanner.load(XMLEntityScanner.java:1904)
	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLEntityScanner.arrangeCapacity(XMLEntityScanner.java:1770)
	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLEntityScanner.skipString(XMLEntityScanner.java:1808)
	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLVersionDetector.determineDocVersion(XMLVersionDetector.java:158)
	at java.xml/com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:860)
	at java.xml/com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:824)
	at java.xml/com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:141)
	at java.xml/com.sun.org.apache.xerces.internal.parsers.DOMParser.parse(DOMParser.java:246)
	at java.xml/com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl.parse(DocumentBuilderImpl.java:339)
	at org.eclipse.jdt.internal.corext.util.History.load(History.java:256)
	... 59 more
!SUBENTRY 1 org.eclipse.jdt.ui 4 4 2022-06-14 15:55:22.808
!MESSAGE Problems reading information from XML 'QualifiedTypeNameHistory.xml'
!STACK 0
java.io.IOException: El proveedor de sincronización en la nube no pudo realizar la operación porque la red no está disponible
	at java.base/java.io.FileInputStream.readBytes(Native Method)
	at java.base/java.io.FileInputStream.read(FileInputStream.java:271)
	at java.base/sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:297)
	at java.base/sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:339)
	at java.base/sun.nio.cs.StreamDecoder.read(StreamDecoder.java:188)
	at java.base/java.io.InputStreamReader.read(InputStreamReader.java:181)
	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLEntityScanner.load(XMLEntityScanner.java:1904)
	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLEntityScanner.arrangeCapacity(XMLEntityScanner.java:1770)
	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLEntityScanner.skipString(XMLEntityScanner.java:1808)
	at java.xml/com.sun.org.apache.xerces.internal.impl.XMLVersionDetector.determineDocVersion(XMLVersionDetector.java:158)
	at java.xml/com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:860)
	at java.xml/com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:824)
	at java.xml/com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:141)
	at java.xml/com.sun.org.apache.xerces.internal.parsers.DOMParser.parse(DOMParser.java:246)
	at java.xml/com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl.parse(DocumentBuilderImpl.java:339)
	at org.eclipse.jdt.internal.corext.util.History.load(History.java:256)
	at org.eclipse.jdt.internal.corext.util.History.load(History.java:174)
	at org.eclipse.jdt.internal.corext.util.QualifiedTypeNameHistory.<init>(QualifiedTypeNameHistory.java:36)
	at org.eclipse.jdt.internal.corext.util.QualifiedTypeNameHistory.getDefault(QualifiedTypeNameHistory.java:29)
	at org.eclipse.jdt.internal.corext.util.QualifiedTypeNameHistory.remember(QualifiedTypeNameHistory.java:61)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaTypeCompletionProposal.rememberSelection(LazyJavaTypeCompletionProposal.java:254)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaTypeCompletionProposal.apply(LazyJavaTypeCompletionProposal.java:217)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.apply(LazyGenericTypeProposal.java:274)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:508)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:446)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:999)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:948)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1373)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:800)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:766)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6101)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5795)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1094)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1519)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4882)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4760)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.equinox.p2.transport.ecf 2 0 2022-06-14 16:08:55.277
!MESSAGE Connection to http://marketplace.eclipse.org/category/free-tagging/fileExtension_deustea.csv%2CfileExtension_csv/api/p?client=org.eclipse.epp.mpc.core&os=win32&platform.version=4.19 failed on marketplace.eclipse.org. Retry attempt 0 started
!STACK 0
java.net.UnknownHostException: marketplace.eclipse.org
	at java.base/java.net.InetAddress$CachedAddresses.get(InetAddress.java:800)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1507)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1366)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1300)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.performConnect(HttpClientRetrieveFileTransfer.java:1003)
	at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.access$0(HttpClientRetrieveFileTransfer.java:995)
	at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer$1.performFileTransfer(HttpClientRetrieveFileTransfer.java:991)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.epp.mpc.ui 4 0 2022-06-14 16:08:55.481
!MESSAGE File support discovery for *.csv failed
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot complete request to http://marketplace.eclipse.org/category/free-tagging/fileExtension_deustea.csv%2CfileExtension_csv/api/p?client=org.eclipse.epp.mpc.core&os=win32&platform.version=4.19: Cannot resolve host

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:200)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:130)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:117)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.processSearchRequest(DefaultMarketplaceService.java:501)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:528)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:1)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.lambda$1(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.performSearch(CachingMarketplaceService.java:331)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:318)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:85)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:69)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Cannot resolve host

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:117)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:165)
	... 12 more
	Suppressed: org.eclipse.core.runtime.CoreException: Unknown Host: http://marketplace.eclipse.org/category/free-tagging/fileExtension_deustea.csv%2CfileExtension_csv/api/p?client=org.eclipse.epp.mpc.core&os=win32&platform.version=4.19
		at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.stream(RepositoryTransport.java:196)
		at org.eclipse.oomph.p2.internal.core.CachingTransport.stream(CachingTransport.java:262)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:564)
		at org.eclipse.epp.internal.mpc.core.util.AbstractP2TransportFactory.invokeStream(AbstractP2TransportFactory.java:37)
		at org.eclipse.epp.internal.mpc.core.util.TransportFactory.lambda$0(TransportFactory.java:421)
		at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.primaryFailed(FallbackTransportFactory.java:131)
		at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:91)
		... 13 more
	Caused by: java.net.UnknownHostException: marketplace.eclipse.org
		at java.base/java.net.InetAddress$CachedAddresses.get(InetAddress.java:800)
		at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1507)
		at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1366)
		at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1300)
		at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
		at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
		at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
		at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
		at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
		at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
		at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
		at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
		at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
		at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
		at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.performConnect(HttpClientRetrieveFileTransfer.java:1003)
		at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.access$0(HttpClientRetrieveFileTransfer.java:995)
		at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer$1.performFileTransfer(HttpClientRetrieveFileTransfer.java:991)
		at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:76)
		... 1 more
Caused by: java.net.UnknownHostException: Host desconocido (marketplace.eclipse.org)
	at java.base/java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)
	at java.base/java.net.InetAddress$PlatformNameService.lookupAllHostAddr(InetAddress.java:932)
	at java.base/java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1517)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:851)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1507)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1366)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1300)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:82)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:74)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:41)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:102)
	... 14 more
!SUBENTRY 1 org.eclipse.epp.mpc.core 4 0 2022-06-14 16:08:55.482
!MESSAGE Cannot complete request to http://marketplace.eclipse.org/category/free-tagging/fileExtension_deustea.csv%2CfileExtension_csv/api/p?client=org.eclipse.epp.mpc.core&os=win32&platform.version=4.19: Cannot resolve host

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot resolve host

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:117)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:165)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:130)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:117)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.processSearchRequest(DefaultMarketplaceService.java:501)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:528)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:1)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.lambda$1(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.performSearch(CachingMarketplaceService.java:331)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:318)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:85)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:69)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
	Suppressed: org.eclipse.core.runtime.CoreException: Unknown Host: http://marketplace.eclipse.org/category/free-tagging/fileExtension_deustea.csv%2CfileExtension_csv/api/p?client=org.eclipse.epp.mpc.core&os=win32&platform.version=4.19
		at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.stream(RepositoryTransport.java:196)
		at org.eclipse.oomph.p2.internal.core.CachingTransport.stream(CachingTransport.java:262)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:564)
		at org.eclipse.epp.internal.mpc.core.util.AbstractP2TransportFactory.invokeStream(AbstractP2TransportFactory.java:37)
		at org.eclipse.epp.internal.mpc.core.util.TransportFactory.lambda$0(TransportFactory.java:421)
		at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.primaryFailed(FallbackTransportFactory.java:131)
		at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:91)
		... 13 more
	Caused by: java.net.UnknownHostException: marketplace.eclipse.org
		at java.base/java.net.InetAddress$CachedAddresses.get(InetAddress.java:800)
		at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1507)
		at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1366)
		at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1300)
		at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
		at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
		at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
		at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
		at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
		at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
		at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
		at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
		at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
		at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
		at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.performConnect(HttpClientRetrieveFileTransfer.java:1003)
		at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.access$0(HttpClientRetrieveFileTransfer.java:995)
		at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer$1.performFileTransfer(HttpClientRetrieveFileTransfer.java:991)
		at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:76)
		... 1 more
Caused by: java.net.UnknownHostException: Host desconocido (marketplace.eclipse.org)
	at java.base/java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)
	at java.base/java.net.InetAddress$PlatformNameService.lookupAllHostAddr(InetAddress.java:932)
	at java.base/java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1517)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:851)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1507)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1366)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1300)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:82)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:74)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:41)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:102)
	... 14 more
Contains: Cannot resolve host

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
java.net.UnknownHostException: Host desconocido (marketplace.eclipse.org)
	at java.base/java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)
	at java.base/java.net.InetAddress$PlatformNameService.lookupAllHostAddr(InetAddress.java:932)
	at java.base/java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1517)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:851)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1507)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1366)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1300)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:82)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:74)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:41)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:102)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:165)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:130)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:117)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.processSearchRequest(DefaultMarketplaceService.java:501)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:528)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:1)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.lambda$1(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.performSearch(CachingMarketplaceService.java:331)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:318)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:85)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:69)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 2 org.eclipse.epp.mpc.core 4 0 2022-06-14 16:08:55.482
!MESSAGE Cannot resolve host

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
!STACK 0
java.net.UnknownHostException: Host desconocido (marketplace.eclipse.org)
	at java.base/java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)
	at java.base/java.net.InetAddress$PlatformNameService.lookupAllHostAddr(InetAddress.java:932)
	at java.base/java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1517)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:851)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1507)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1366)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1300)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:82)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:74)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:41)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:102)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:165)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:130)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:117)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.processSearchRequest(DefaultMarketplaceService.java:501)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:528)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:1)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.lambda$1(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.performSearch(CachingMarketplaceService.java:331)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:318)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:85)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:69)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 3 org.eclipse.epp.mpc.core 4 0 2022-06-14 16:08:55.482
!MESSAGE Cannot resolve host

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
!STACK 0
java.net.UnknownHostException: Host desconocido (marketplace.eclipse.org)
	at java.base/java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)
	at java.base/java.net.InetAddress$PlatformNameService.lookupAllHostAddr(InetAddress.java:932)
	at java.base/java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1517)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:851)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1507)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1366)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1300)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:82)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:74)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:41)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:102)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:165)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:130)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:117)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.processSearchRequest(DefaultMarketplaceService.java:501)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:528)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:1)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.lambda$1(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.performSearch(CachingMarketplaceService.java:331)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:318)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:85)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:69)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.equinox.preferences 1 1 2022-06-14 17:36:00.575
!MESSAGE Exception loading preferences from: C:/Users/i.cubillo/OneDrive - Universidad de Deusto/Documentos/Eclipse/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.help.base.prefs.
!STACK 0
java.io.IOException: El proveedor de sincronización en la nube no pudo realizar la operación porque la red no está disponible
	at java.base/java.io.FileInputStream.readBytes(Native Method)
	at java.base/java.io.FileInputStream.read(FileInputStream.java:271)
	at java.base/java.io.BufferedInputStream.read1(BufferedInputStream.java:282)
	at java.base/java.io.BufferedInputStream.read(BufferedInputStream.java:343)
	at java.base/java.io.FilterInputStream.read(FilterInputStream.java:132)
	at java.base/java.io.FilterInputStream.read(FilterInputStream.java:106)
	at java.base/java.util.Properties$LineReader.readLine(Properties.java:503)
	at java.base/java.util.Properties.load0(Properties.java:419)
	at java.base/java.util.Properties.load(Properties.java:408)
	at org.eclipse.core.internal.preferences.EclipsePreferences.loadProperties(EclipsePreferences.java:695)
	at org.eclipse.core.internal.preferences.EclipsePreferences.load(EclipsePreferences.java:726)
	at org.eclipse.core.internal.preferences.EclipsePreferences.load(EclipsePreferences.java:678)
	at org.eclipse.core.internal.preferences.EclipsePreferences.create(EclipsePreferences.java:370)
	at org.eclipse.core.internal.preferences.EclipsePreferences.getChild(EclipsePreferences.java:492)
	at org.eclipse.core.internal.preferences.EclipsePreferences.internalNode(EclipsePreferences.java:622)
	at org.eclipse.core.internal.preferences.EclipsePreferences.node(EclipsePreferences.java:767)
	at org.eclipse.core.internal.preferences.PreferencesService$5.run(PreferencesService.java:620)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.preferences.PreferencesService.getNodes(PreferencesService.java:600)
	at org.eclipse.core.internal.preferences.PreferencesService.getString(PreferencesService.java:686)
	at org.eclipse.help.ui.internal.HelpActivitySupport.<init>(HelpActivitySupport.java:126)
	at org.eclipse.help.ui.internal.HelpUIPlugin.start(HelpUIPlugin.java:83)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1012)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:366)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:506)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:346)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:480)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:171)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:617)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.WorkbenchPlugin.lambda$0(WorkbenchPlugin.java:287)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchPlugin.createExtension(WorkbenchPlugin.java:285)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem$2.initializePluggableHelpUI(WorkbenchHelpSystem.java:506)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem$2.run(WorkbenchHelpSystem.java:470)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem.initializePluggableHelpUI(WorkbenchHelpSystem.java:445)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem.getHelpUI(WorkbenchHelpSystem.java:433)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem.resolve(WorkbenchHelpSystem.java:736)
	at org.eclipse.jdt.internal.ui.actions.OpenBrowserUtil.lambda$2(OpenBrowserUtil.java:55)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.actions.OpenBrowserUtil.internalOpen(OpenBrowserUtil.java:54)
	at org.eclipse.jdt.internal.ui.actions.OpenBrowserUtil.lambda$0(OpenBrowserUtil.java:39)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4742)
	at org.eclipse.jdt.internal.ui.actions.OpenBrowserUtil.open(OpenBrowserUtil.java:39)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover$1.handleExternalLink(JavadocHover.java:632)
	at org.eclipse.jdt.internal.ui.viewsupport.JavaElementLinks$1.changing(JavaElementLinks.java:316)
	at org.eclipse.swt.browser.IE.lambda$6(IE.java:525)
	at org.eclipse.swt.ole.win32.OleEventTable.sendEvent(OleEventTable.java:58)
	at org.eclipse.swt.ole.win32.OleEventSink.notifyListener(OleEventSink.java:160)
	at org.eclipse.swt.ole.win32.OleEventSink.Invoke(OleEventSink.java:128)
	at org.eclipse.swt.ole.win32.OleEventSink.access$1(OleEventSink.java:105)
	at org.eclipse.swt.ole.win32.OleEventSink$1.method6(OleEventSink.java:79)
	at org.eclipse.swt.internal.ole.win32.COMObject.callback6(COMObject.java:120)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.equinox.preferences 4 4 2022-06-14 17:36:00.576
!MESSAGE Exception loading preferences from: C:/Users/i.cubillo/OneDrive - Universidad de Deusto/Documentos/Eclipse/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.help.base.prefs.
!STACK 0
org.osgi.service.prefs.BackingStoreException: Exception loading preferences from: C:/Users/i.cubillo/OneDrive - Universidad de Deusto/Documentos/Eclipse/.metadata/.plugins/org.eclipse.core.runtime/.settings/org.eclipse.help.base.prefs.
	at org.eclipse.core.internal.preferences.EclipsePreferences.loadProperties(EclipsePreferences.java:704)
	at org.eclipse.core.internal.preferences.EclipsePreferences.load(EclipsePreferences.java:726)
	at org.eclipse.core.internal.preferences.EclipsePreferences.load(EclipsePreferences.java:678)
	at org.eclipse.core.internal.preferences.EclipsePreferences.create(EclipsePreferences.java:370)
	at org.eclipse.core.internal.preferences.EclipsePreferences.getChild(EclipsePreferences.java:492)
	at org.eclipse.core.internal.preferences.EclipsePreferences.internalNode(EclipsePreferences.java:622)
	at org.eclipse.core.internal.preferences.EclipsePreferences.node(EclipsePreferences.java:767)
	at org.eclipse.core.internal.preferences.PreferencesService$5.run(PreferencesService.java:620)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.preferences.PreferencesService.getNodes(PreferencesService.java:600)
	at org.eclipse.core.internal.preferences.PreferencesService.getString(PreferencesService.java:686)
	at org.eclipse.help.ui.internal.HelpActivitySupport.<init>(HelpActivitySupport.java:126)
	at org.eclipse.help.ui.internal.HelpUIPlugin.start(HelpUIPlugin.java:83)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:554)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1012)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:366)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:506)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:346)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:480)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:171)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:617)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.WorkbenchPlugin.lambda$0(WorkbenchPlugin.java:287)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchPlugin.createExtension(WorkbenchPlugin.java:285)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem$2.initializePluggableHelpUI(WorkbenchHelpSystem.java:506)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem$2.run(WorkbenchHelpSystem.java:470)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem.initializePluggableHelpUI(WorkbenchHelpSystem.java:445)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem.getHelpUI(WorkbenchHelpSystem.java:433)
	at org.eclipse.ui.internal.help.WorkbenchHelpSystem.resolve(WorkbenchHelpSystem.java:736)
	at org.eclipse.jdt.internal.ui.actions.OpenBrowserUtil.lambda$2(OpenBrowserUtil.java:55)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.actions.OpenBrowserUtil.internalOpen(OpenBrowserUtil.java:54)
	at org.eclipse.jdt.internal.ui.actions.OpenBrowserUtil.lambda$0(OpenBrowserUtil.java:39)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4742)
	at org.eclipse.jdt.internal.ui.actions.OpenBrowserUtil.open(OpenBrowserUtil.java:39)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover$1.handleExternalLink(JavadocHover.java:632)
	at org.eclipse.jdt.internal.ui.viewsupport.JavaElementLinks$1.changing(JavaElementLinks.java:316)
	at org.eclipse.swt.browser.IE.lambda$6(IE.java:525)
	at org.eclipse.swt.ole.win32.OleEventTable.sendEvent(OleEventTable.java:58)
	at org.eclipse.swt.ole.win32.OleEventSink.notifyListener(OleEventSink.java:160)
	at org.eclipse.swt.ole.win32.OleEventSink.Invoke(OleEventSink.java:128)
	at org.eclipse.swt.ole.win32.OleEventSink.access$1(OleEventSink.java:105)
	at org.eclipse.swt.ole.win32.OleEventSink$1.method6(OleEventSink.java:79)
	at org.eclipse.swt.internal.ole.win32.COMObject.callback6(COMObject.java:120)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
Caused by: java.io.IOException: El proveedor de sincronización en la nube no pudo realizar la operación porque la red no está disponible
	at java.base/java.io.FileInputStream.readBytes(Native Method)
	at java.base/java.io.FileInputStream.read(FileInputStream.java:271)
	at java.base/java.io.BufferedInputStream.read1(BufferedInputStream.java:282)
	at java.base/java.io.BufferedInputStream.read(BufferedInputStream.java:343)
	at java.base/java.io.FilterInputStream.read(FilterInputStream.java:132)
	at java.base/java.io.FilterInputStream.read(FilterInputStream.java:106)
	at java.base/java.util.Properties$LineReader.readLine(Properties.java:503)
	at java.base/java.util.Properties.load0(Properties.java:419)
	at java.base/java.util.Properties.load(Properties.java:408)
	at org.eclipse.core.internal.preferences.EclipsePreferences.loadProperties(EclipsePreferences.java:695)
	... 83 more

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:07:50.678
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read();
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-14 18:07:50.679
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-14 18:07:50.679
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:07:50.767
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read();
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:07:50.768
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:07:50.769
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:07:51.386
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read();
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:07:51.386
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:07:51.387
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:07:51.401
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read();
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:07:51.402
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:07:51.402
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:07:54.207
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read();
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:07:54.208
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:07:54.208
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:07:58.867
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read();
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:07:58.868
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:07:58.868
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:00.700
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-14 18:08:00.701
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-14 18:08:00.701
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:01.192
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:01.193
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:01.193
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:01.392
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:01.392
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:01.393
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:01.408
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:01.409
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:01.409
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:22.704
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:22.705
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:22.705
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:27.737
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-14 18:08:27.737
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-14 18:08:27.738
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:27.751
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:27.752
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:27.752
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:27.768
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:27.769
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:27.769
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:27.781
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:27.782
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:27.783
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:27.795
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:27.796
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:27.796
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:27.808
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:27.809
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:27.809
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:27.822
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:27.823
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:27.823
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:27.836
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:27.837
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:27.838
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:27.850
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:27.850
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:27.851
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:27.862
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:27.863
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:27.863
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:27.875
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:27.875
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:27.876
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:27.887
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:27.887
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:27.888
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:27.898
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:27.899
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:27.899
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:27.910
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:27.911
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:27.911
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:27.922
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:27.923
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:27.924
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:28.204
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:28.205
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:28.205
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:28.216
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1031)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2022-06-14 18:08:28.217
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1031)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:29.166
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:29.167
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:29.167
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:29.178
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1031)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2022-06-14 18:08:29.179
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1031)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:30.375
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:30.376
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:30.376
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:30.387
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1031)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2022-06-14 18:08:30.388
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1031)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:35.238
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:35.239
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:35.240
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:35.250
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1031)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2022-06-14 18:08:35.251
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1031)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:37.230
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:37.231
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:37.231
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:37.749
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:37.750
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:37.751
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:37.761
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1031)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2022-06-14 18:08:37.762
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1031)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:39.038
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) ois.read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:39.039
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:39.039
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:41.763
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) oiread(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-14 18:08:41.763
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-14 18:08:41.764
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:41.776
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) oiread(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:41.777
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:41.778
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:41.789
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) oiread(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:41.790
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:41.791
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:41.802
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) oiread(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1031)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2022-06-14 18:08:41.803
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1031)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:43.277
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-14 18:08:43.278
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-14 18:08:43.279
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:44.160
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) read(aPedido);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:44.161
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:44.161
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:45.293
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) read(ois);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2022-06-14 18:08:45.294
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2022-06-14 18:08:45.295
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2022-06-14 18:08:45.871
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package deustea;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Scanner;

public class Deustea {
	protected static ArrayList<Pedido> pedidos;
	protected ArrayList<Producto> productos;
	protected ArrayList<Servicio> servicios;
	protected ArrayList<Recambio> recambios = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia1 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia2 = new ArrayList<>();
	protected ArrayList<Pedido> arraylistVacia3 = new ArrayList<>();
	// TAREA2: Mapa
	protected static HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado = new HashMap<>(); 
	
	/** Constructor con argumentos
	 * @param pedidos almacenados
	 * @param productos disponibles
	 * @param servicios disponibles
	 */
	public Deustea(ArrayList<Pedido> pedidos, ArrayList<Producto> productos, ArrayList<Servicio> servicios, HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		super();
		this.setPedidos(pedidos);
		this.setProductos(productos);
		this.setServicios(servicios);
		this.setPedidosPorEstado(pedidosPorEstado);
	}
	
	/** Constructor por defecto, con todas las estructuras de datos vacÃ­as
	 */
	public Deustea() {
		super();
		this.pedidos = new ArrayList<Pedido>();
		this.productos = new ArrayList<Producto>();
		this.servicios = new ArrayList<Servicio>();
		this.pedidosPorEstado = new HashMap<Estado, ArrayList<Pedido>>();
		
	}

	/**
	 * @return pedidos almacenados
	 */
	public ArrayList<Pedido> getPedidos() {
		return pedidos;
	}

	/**
	 * @param pedidos almacenados
	 */
	public void setPedidos(ArrayList<Pedido> pedidos) {
		if (pedidos != null) {
			this.pedidos = pedidos;
		}
	}

	/**
	 * @return productos disponibles
	 */
	public ArrayList<Producto> getProductos() {
		return productos;
	}

	/**
	 * @param productos disponibles
	 */
	public void setProductos(ArrayList<Producto> productos) {
		if (pedidos != null) {
			this.productos = productos;
		}
	}

	/**
	 * @return servicios disponibles
	 */
	public ArrayList<Servicio> getServicios() {
		return servicios;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setServicios(ArrayList<Servicio> servicios) {
		if (servicios != null) {
			this.servicios = servicios;
		}
	}

	/** Convierte un Deustea en String
	 */
	@Override
	public String toString() {
		return "Deustea [pedidos=" + pedidos + ", productos=" + productos + ", servicios=" + servicios + ", pedidosPorEstado=" + pedidosPorEstado +"]";
	}
	
	public HashMap<Estado, ArrayList<Pedido>> getPedidosPorEstado() {
		return pedidosPorEstado;
	}

	/**
	 * @param servicios disponibles
	 */
	public void setPedidosPorEstado(HashMap<Estado, ArrayList<Pedido>> pedidosPorEstado) {
		if (pedidosPorEstado != null) {
			this.pedidosPorEstado = pedidosPorEstado;
		}
	}
	
	/**
	 * @param pedidosPorEstado pedidos clasificados por su estado
	 */
	public void inicializar() {
		ArrayList<Mueble> muebles = new ArrayList<Mueble>(); 
		
		// Cargamos los muebles desde fichero
		try {
			Scanner sc = new Scanner(new File("deustea.csv"));
			String[] categorias = { "COCINA", "CAMAS", "ESTANTERIAS", "ARMARIOS", "DESAYUNO", "SILLAS", 
					"ALMACENAMIENTO", "INFANTIL", "SOFAS", "MESAS" };
						
			while(sc.hasNextLine()) {
				String linea = sc.nextLine();
				String[] campos = linea.split(";");
				int pos = Arrays.asList(categorias).indexOf(campos[2]);
				Mueble nuevo = new Mueble(Integer.parseInt(campos[0]), campos[1], Categoria.values()[pos], Double.parseDouble(campos[3]));
				this.productos.add(nuevo);
				muebles.add(nuevo);
			}
			
			sc.close();
			
		} catch (IOException e) {
			System.err.println("Error cargando productos");
		}
		
		// TAREA1: Crear los recambios aleatoriamente
		
		for(int i = 0; i <= 100; i++) {
			// implementar random
			
			Mueble mr = muebles.get(i);
			Recambio e = new Recambio(i, mr.getNombre() , mr, i);
			recambios.add(e);
		}
		
		// Creamos los servicios
		for (TipoServicio tipo : TipoServicio.values()) {
			for (int i = 0; i < 4; i++) {
				this.servicios.add(new Servicio(tipo, i));
			}
		}
	}
	
	/** AÃ±ade un pedido a las estructuras de datos de Deustea
	 * @param pedido que se aÃ±ade
	 */
	public void anyadirPedido(Pedido pedido) {
		pedidos.add(pedido);
		// TAREA2: actualizar el mapa
		
		try {
			
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}	
//		System.out.println(pedidosPorEstado);
	}
	
	/** Borra un pedido de las estructuras de datos de Deustea
	 * @param pedido que se borra
	 */
	public void borrarPedido(Pedido pedido) {
		pedidos.remove(pedido);
		// TAREA2: actualizar el mapa
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
	}
	
	/** Actualiza el estado de un pedido y las estructuras de datos de Deustea
	 * @param pedido que se actualiza
	 * @param estado nuevo
	 */
	public void actualizarEstadoPedido(Pedido pedido, Estado estado) {
//		System.out.println(pedidosPorEstado);
		pedidosPorEstado.get(pedido.getEstado()).remove(pedido);
//		System.out.println(pedidosPorEstado);
		int posicion = pedidos.lastIndexOf(pedido);
		pedidos.get(posicion).setEstado(estado);
		// TAREA2: actualizar el mapa
		try {
			pedidosPorEstado.get(pedido.getEstado()).add(pedido);
		} catch (Exception e) {
			ArrayList<Pedido> arrayVacia = new ArrayList<>();
			arrayVacia.add(pedido);
			pedidosPorEstado.put(pedido.getEstado(), arrayVacia);
		}
//		System.out.println(pedidosPorEstado);
	}
	
	/** Regenera el mapa pedidosPorEstado
	 */
	public static void regenerarPedidosPorEstado() {
		// TAREA2: regenerar el mapa
		pedidosPorEstado.clear();
		for(Pedido pedidoRegenerar: pedidos) {
			try {
				pedidosPorEstado.get(pedidoRegenerar.getEstado()).add(pedidoRegenerar);
			} catch (Exception e) {
				ArrayList<Pedido> arrayVacia = new ArrayList<>();
				arrayVacia.add(pedidoRegenerar);
				pedidosPorEstado.put(pedidoRegenerar.getEstado(), arrayVacia);
			}
		}
	}
	
	/** Guarda los datos de pedidos en un fichero binario
	 * @param fichero en el que se guardan los datos
	 */
	
	public void guardarPedidos(String nombreDelFichero, ArrayList<Pedido> datosPedido) {
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(nombreDelFichero));
			for(Pedido ePedido: datosPedido) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public static void guardarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			FileOutputStream fos = new FileOutputStream(fichero);
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			
			oos.write(pedidos);
			oos.close();
		} catch (FileNotFoundException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			BufferedWriter bw = new BufferedWriter(new FileWriter(fichero));
			for(Pedido ePedido: pedidos) {
				String line = ePedido.getCliente() + ";" + ePedido.getFecha() + ";" + ePedido.getElementos() + ";" + ePedido.getEstado() ;
				System.out.println(line);
				bw.write(line);
				bw.newLine();
				
			}
			bw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/** Carga los datos de pedidos desde un fichero binario
	 * @param fichero desde el que se cargan los datos
	 */
	public static void cargarPedidos(String fichero) {
		// TAREA3: ficheros
		
		try {
			ArrayList<Pedido> aPedido = new ArrayList<>();
			FileInputStream fis = new FileInputStream(fichero);
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			
			(ArrayList<Pedido>) read(ois);
			
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
//		try {
//			BufferedReader br = new BufferedReader(new FileReader(fichero));
//			
//			String linea = br.readLine();
//			while (linea != null) {
//				String[] campos = linea.split(";");
//				String A = campos[0];
////				Date B = (Date) campos[1];
////				ArrayList<Pagable> = campos[2];
//				Estado D = (Estado) campos[3];
//				Pedido nPedido = new Pedido(A, B, C, null);
//				nPedido.setEstado(D);
//				pedidos.add(null);
//				
//			}
//		} catch (IOException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
		
		regenerarPedidosPorEstado();
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2022-06-14 18:08:45.872
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2022-06-14 18:08:45.873
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-06-22 00:54:55.619 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-22 00:55:22.168
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-22 00:55:22.168
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4cf230bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dc55719,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-22 00:55:22.168
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64665781,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c2bea52,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-22 00:55:40.769
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Iker Cubillo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.e4.ui.workbench 2 0 2022-06-22 00:55:40.803
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.search.SearchResultView" id and the "Classic Search" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2022-06-22 00:55:40.805
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.wst.xml.ui.views.annotations.XMLAnnotationsView" id and the "Documentation" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.e4.ui.workbench 2 0 2022-06-22 00:55:40.807
!MESSAGE Removing PartDescriptorImpl with the "org.eclipse.wst.xml.ui.contentmodel.view" id and the "Content Model" label.It points to the non available "bundleclass://org.eclipse.ui.workbench/org.eclipse.ui.internal.e4.compatibility.CompatibilityView" class. Bundle might have been uninstalled

!ENTRY org.eclipse.ui 4 0 2022-06-22 00:56:08.913
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (El sistema no puede encontrar la ruta especificada))
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4779)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setVisible(UIElementImpl.java:361)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.updateVisibility(ContributionRecord.java:113)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:191)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:202)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:256)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:114)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1068)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5143)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4775)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2286)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4101)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: org.eclipse.swt.SWTException: i/o error (java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (El sistema no puede encontrar la ruta especificada))
	at org.eclipse.swt.SWT.error(SWT.java:4918)
	at org.eclipse.swt.SWT.error(SWT.java:4833)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:184)
	at org.eclipse.tm.terminal.view.ui.local.showin.ExternalExecutablesUtils.loadImage(ExternalExecutablesUtils.java:38)
	at org.eclipse.tm.terminal.view.ui.local.showin.DynamicContributionItems.getContributionItems(DynamicContributionItems.java:74)
	at org.eclipse.ui.actions.CompoundContributionItem.getContributionItemsToFill(CompoundContributionItem.java:83)
	at org.eclipse.ui.actions.CompoundContributionItem.fill(CompoundContributionItem.java:57)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:146)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeUIElementTopicVisible(MenuManagerRenderer.java:213)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:577)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 60 more
Caused by: java.io.FileNotFoundException: C:\Program Files\Git\mingw64\share\git\git-for-windows.ico (El sistema no puede encontrar la ruta especificada)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:216)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:157)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:111)
	at org.eclipse.swt.graphics.ImageLoader.load(ImageLoader.java:181)
	... 73 more

!ENTRY org.eclipse.core.resources 4 567 2022-06-22 00:56:12.191
!MESSAGE The project description file (.project) for 'Concesionario' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Concesionario' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:763)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1061)
	at org.eclipse.ui.actions.OpenResourceAction$1.doOpenWithReferences(OpenResourceAction.java:233)
	at org.eclipse.ui.actions.OpenResourceAction$1.runInWorkspace(OpenResourceAction.java:279)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2022-06-22 00:57:56.564 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -data C:\Users\Iker Cubillo\OneDrive - Universidad de Deusto\Documentos\Eclipse -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-22 00:58:05.015
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-22 00:58:05.015
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@402f61f5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6480a063,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-22 00:58:05.015
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2f6f4ac4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@727dcc64,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-22 00:58:09.803
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Iker Cubillo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-06-25 17:55:50.388 -----------------------------------------------
eclipse.buildId=4.23.0.I20220308-0310
java.version=18.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2022-06-25 17:56:16.338
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-25 17:56:16.338
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ceb68a1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6de33fde,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2022-06-25 17:56:16.338
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@69c33ea2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@59e0d521,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2022-06-25 17:56:25.623
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Iker Cubillo'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2022-09-14 11:29:45.761 -----------------------------------------------
eclipse.buildId=4.24.0.I20220607-0700
java.version=17.0.3
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -data C:\Users\i.cubillo\OneDrive - Universidad de Deusto\Documentos\Eclipse -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2022-09-14 11:30:01.888
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:01.888
!MESSAGE Could not read metadata for '.org.eclipse.egit.core.cmp'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/.org.eclipse.egit.core.cmp)[567]: java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:01.889
!MESSAGE The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '.org.eclipse.egit.core.cmp' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:01.889
!MESSAGE Could not read metadata for '2020ord'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/2020ord)[567]: java.lang.Exception: The project description file (.project) for '2020ord' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:01.889
!MESSAGE The project description file (.project) for '2020ord' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '2020ord' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.194
!MESSAGE Could not read metadata for '2021ord'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/2021ord)[567]: java.lang.Exception: The project description file (.project) for '2021ord' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.194
!MESSAGE The project description file (.project) for '2021ord' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '2021ord' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.194
!MESSAGE Could not read metadata for 'AAProyectoAlgoritmica'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/AAProyectoAlgoritmica)[567]: java.lang.Exception: The project description file (.project) for 'AAProyectoAlgoritmica' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.195
!MESSAGE The project description file (.project) for 'AAProyectoAlgoritmica' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'AAProyectoAlgoritmica' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.195
!MESSAGE Could not read metadata for 'ALGORITMICA'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/ALGORITMICA)[567]: java.lang.Exception: The project description file (.project) for 'ALGORITMICA' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.195
!MESSAGE The project description file (.project) for 'ALGORITMICA' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'ALGORITMICA' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.196
!MESSAGE Could not read metadata for 'AgenciaViajesDeusto'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/AgenciaViajesDeusto)[567]: java.lang.Exception: The project description file (.project) for 'AgenciaViajesDeusto' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.196
!MESSAGE The project description file (.project) for 'AgenciaViajesDeusto' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'AgenciaViajesDeusto' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.196
!MESSAGE Could not read metadata for 'Algorithmics'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Algorithmics)[567]: java.lang.Exception: The project description file (.project) for 'Algorithmics' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.196
!MESSAGE The project description file (.project) for 'Algorithmics' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Algorithmics' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.196
!MESSAGE Could not read metadata for 'Concesionario'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Concesionario)[567]: java.lang.Exception: The project description file (.project) for 'Concesionario' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.197
!MESSAGE The project description file (.project) for 'Concesionario' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Concesionario' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.197
!MESSAGE Could not read metadata for 'Contador'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Contador)[567]: java.lang.Exception: The project description file (.project) for 'Contador' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.197
!MESSAGE The project description file (.project) for 'Contador' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Contador' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.197
!MESSAGE Could not read metadata for 'DeustoTrain'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/DeustoTrain)[567]: java.lang.Exception: The project description file (.project) for 'DeustoTrain' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.197
!MESSAGE The project description file (.project) for 'DeustoTrain' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'DeustoTrain' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.198
!MESSAGE Could not read metadata for 'EjemploFicheros'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/EjemploFicheros)[567]: java.lang.Exception: The project description file (.project) for 'EjemploFicheros' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.198
!MESSAGE The project description file (.project) for 'EjemploFicheros' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'EjemploFicheros' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.198
!MESSAGE Could not read metadata for 'EjercicioRepaso'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/EjercicioRepaso)[567]: java.lang.Exception: The project description file (.project) for 'EjercicioRepaso' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.198
!MESSAGE The project description file (.project) for 'EjercicioRepaso' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'EjercicioRepaso' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.198
!MESSAGE Could not read metadata for 'EscribeFrases'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/EscribeFrases)[567]: java.lang.Exception: The project description file (.project) for 'EscribeFrases' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.198
!MESSAGE The project description file (.project) for 'EscribeFrases' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'EscribeFrases' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.198
!MESSAGE Could not read metadata for 'Estudiantes'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Estudiantes)[567]: java.lang.Exception: The project description file (.project) for 'Estudiantes' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.199
!MESSAGE The project description file (.project) for 'Estudiantes' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Estudiantes' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.199
!MESSAGE Could not read metadata for 'ExamenIker'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/ExamenIker)[567]: java.lang.Exception: The project description file (.project) for 'ExamenIker' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.199
!MESSAGE The project description file (.project) for 'ExamenIker' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'ExamenIker' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.199
!MESSAGE Could not read metadata for 'ExamenResuelto'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/ExamenResuelto)[567]: java.lang.Exception: The project description file (.project) for 'ExamenResuelto' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.199
!MESSAGE The project description file (.project) for 'ExamenResuelto' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'ExamenResuelto' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.199
!MESSAGE Could not read metadata for 'GestorTareas'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/GestorTareas)[567]: java.lang.Exception: The project description file (.project) for 'GestorTareas' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.199
!MESSAGE The project description file (.project) for 'GestorTareas' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'GestorTareas' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.199
!MESSAGE Could not read metadata for 'Grado'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Grado)[567]: java.lang.Exception: The project description file (.project) for 'Grado' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.199
!MESSAGE The project description file (.project) for 'Grado' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Grado' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.200
!MESSAGE Could not read metadata for 'Hilos'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Hilos)[567]: java.lang.Exception: The project description file (.project) for 'Hilos' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.200
!MESSAGE The project description file (.project) for 'Hilos' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Hilos' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.200
!MESSAGE Could not read metadata for 'Lanzallamas'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Lanzallamas)[567]: java.lang.Exception: The project description file (.project) for 'Lanzallamas' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.200
!MESSAGE The project description file (.project) for 'Lanzallamas' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Lanzallamas' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.200
!MESSAGE Could not read metadata for 'Libreria'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Libreria)[567]: java.lang.Exception: The project description file (.project) for 'Libreria' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.200
!MESSAGE The project description file (.project) for 'Libreria' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Libreria' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.200
!MESSAGE Could not read metadata for 'Multimedia'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Multimedia)[567]: java.lang.Exception: The project description file (.project) for 'Multimedia' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.200
!MESSAGE The project description file (.project) for 'Multimedia' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Multimedia' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.200
!MESSAGE Could not read metadata for 'Numeros'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Numeros)[567]: java.lang.Exception: The project description file (.project) for 'Numeros' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.201
!MESSAGE The project description file (.project) for 'Numeros' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Numeros' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.201
!MESSAGE Could not read metadata for 'PreparatorioExamen2'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/PreparatorioExamen2)[567]: java.lang.Exception: The project description file (.project) for 'PreparatorioExamen2' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.201
!MESSAGE The project description file (.project) for 'PreparatorioExamen2' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'PreparatorioExamen2' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.201
!MESSAGE Could not read metadata for 'Pruebas'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Pruebas)[567]: java.lang.Exception: The project description file (.project) for 'Pruebas' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.201
!MESSAGE The project description file (.project) for 'Pruebas' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Pruebas' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.201
!MESSAGE Could not read metadata for 'RedSocial'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/RedSocial)[567]: java.lang.Exception: The project description file (.project) for 'RedSocial' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.201
!MESSAGE The project description file (.project) for 'RedSocial' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'RedSocial' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.201
!MESSAGE Could not read metadata for 'SeguridadWebs'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/SeguridadWebs)[567]: java.lang.Exception: The project description file (.project) for 'SeguridadWebs' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.201
!MESSAGE The project description file (.project) for 'SeguridadWebs' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'SeguridadWebs' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.201
!MESSAGE Could not read metadata for 'Transporte'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Transporte)[567]: java.lang.Exception: The project description file (.project) for 'Transporte' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.202
!MESSAGE The project description file (.project) for 'Transporte' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Transporte' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.202
!MESSAGE Could not read metadata for 'Ventanas'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Ventanas)[567]: java.lang.Exception: The project description file (.project) for 'Ventanas' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.202
!MESSAGE The project description file (.project) for 'Ventanas' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Ventanas' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.202
!MESSAGE Could not read metadata for 'Zoo'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Zoo)[567]: java.lang.Exception: The project description file (.project) for 'Zoo' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.202
!MESSAGE The project description file (.project) for 'Zoo' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Zoo' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.202
!MESSAGE Could not read metadata for 'deustea-fuentes'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/deustea-fuentes)[567]: java.lang.Exception: The project description file (.project) for 'deustea-fuentes' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.202
!MESSAGE The project description file (.project) for 'deustea-fuentes' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'deustea-fuentes' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.202
!MESSAGE Could not read metadata for 'lab5'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/lab5)[567]: java.lang.Exception: The project description file (.project) for 'lab5' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2022-09-14 11:30:02.202
!MESSAGE The project description file (.project) for 'lab5' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'lab5' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:525)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:499)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
